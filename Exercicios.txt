espostas dos Exercícios do Capítulo 3 (RAG com Memória)1. Diferença entre RAG Tradicional e RAG com Memória (Analogia do Professor)O RAG Tradicional funciona como um consultor que tem acesso imediato a uma vasta biblioteca, mas trata cada pergunta de forma isolada, sem recordar do diálogo anterior1. É como um professor que só usa o livro para responder, esquecendo o que foi discutido na aula anterior.O RAG com Memória incorpora a lembrança contínua de interações passadas2222. É como um professor que anota e retoma pontos importantes ao longo da jornada, conseguindo contextualizar perguntas com base no que já foi discutido3333.2. O papel da classe Memory e o impacto do método add_memoryO papel da classe Memory é ser o mecanismo de armazenamento rápido (usando Redis) para o histórico do diálogo444444.Se o método add_memory não for chamado após cada resposta gerada pelo modelo, o sistema sofrerá de amnésia5. Ele não conseguirá lembrar das interações anteriores, tratando cada pergunta nova como se fosse a primeira vez, e a coerência do diálogo será perdida6.3. Onde a resposta é enviada para a memória e por que é fundamental?A resposta do modelo é enviada para a memória no fluxo principal (dentro do while True), após a geração da resposta (response = generation.generate(prompt)), através da chamada augmentation.add_memory(response)7777.Este passo é fundamental porque garante que a resposta mais recente seja armazenada e possa ser recuperada em interações futuras, mantendo a coerência e a linha narrativa do diálogo8888.4. Modificação da classe Augmentation para incluir apenas as últimas 3 interações e o impacto dessa mudança.Modificação (Snippet Lógico): Dentro do método generate_prompt da classe Augmentation, a chamada para obter o histórico (self.memory_rag.get_conversation(self.talk_id)) deve ser fatiada para obter apenas os últimos 6 itens (as últimas 3 interações completas de usuário e sistema).Python# Dentro de generate_prompt:
historico_completo = self.memory_rag.get_conversation(self.talk_id)
# Pega apenas os últimos 6 itens (3 perguntas + 3 respostas)
historico_limitado = historico_completo[:6] if historico_completo else []
# E insere 'historico_limitado' no prompt
Impacto no Comportamento do RAG: Reduz o contexto de memória enviado ao LLM, o que é importante para controlar o custo de tokens (evitando atingir cotas, como o erro 429) e manter o foco da conversa nos tópicos mais recentes9. O RAG não conseguirá se referir a conversas muito antigas.5. Crie um teste em que duas sessões de conversa (TALK_ID diferentes) sejam executadas simultaneamente.(Este é um teste prático que não pode ser executado, mas a lógica para demonstrar a separação é a seguinte):O sistema mantém o histórico separado porque o Redis armazena as conversas sob chaves únicas, padronizadas com o prefixo 'conversation:' seguido do TALK_ID10101010101010101010101010101010.AçãoTALK_IDChave no RedisUsuário A pergunta"sessao-A"conversation:sessao-AUsuário B pergunta"sessao-B"conversation:sessao-BO Augmentation usa o self.talk_id para consultar a chave correta11, garantindo que o histórico de A jamais seja misturado com o histórico de B.6. Cenários em que a expiração das conversas é vantajosa e em quais não.Vantajosa (Faz sentido que as memórias se apaguem):Sistemas de Atendimento Temporário (SAC, E-commerce): O histórico só é relevante por algumas horas.Bots de Campanhas Promocionais: O diálogo é descartado após o término da promoção ou do dia.Otimização de Recursos: O Redis permite configurar expiração automática de dados 12, o que otimiza o uso de memória (RAM) para conversas antigas13.Desvantajosa (Não faz sentido que as memórias se apaguem):Assistentes Educacionais/Tutores: O histórico é necessário para acompanhar a progressão e o aprendizado do aluno14.Consultores Jurídicos/Médicos: A continuidade do caso e a totalidade do contexto são cruciais15.7. Troque a condição de parada de ’sair’ para outro comando de sua escolha.(Esta é uma modificação de código simples que deve ser feita no arquivo principal main.py):O trecho a ser modificado é o if user_query.lower() == 'sair':16.Exemplo: Trocar 'sair' por 'fim':Python# No loop while True do main.py
if user_query.lower() == 'fim':
    print("Até a próxima!")
    break
8. Ordem das mensagens na memória e a justificativa da inserção no início da lista.A decisão é de inserir a nova mensagem no início da lista (history.insert(0, {...}))17.Justificativa: Em programação, especialmente em contextos de chat, é comum que as informações mais recentes sejam as mais relevantes (o que chamamos de recência). Ao inserir no início (índice 0), garante-se que:As mensagens mais recentes são as primeiras a serem lidas.É mais fácil limitar o contexto para o LLM (por exemplo, historico[:N] pega as N interações mais recentes).9. Implemente uma função que mostre, a qualquer momento, o histórico completo da conversa atual. Utilize os métodos já existentes na classe Memory.(Esta é uma adição de código, que pode ser implementada na classe Memory ou no bloco main.py):No seu main.py, dentro do while True, você pode adicionar uma condição para o usuário digitar um comando como ver_historico:Python# No loop while True do main.py
if user_query.lower() == 'ver_historico':
    conversa = augmentation.get_conversation()
    if conversa:
        print("\n--- HISTÓRICO COMPLETO ---")
        for msg in conversa:
            print(f"[{msg['role'].upper()}]: {msg['content']}")
        print("--------------------------")
    else:
        print("Nenhuma conversa registrada.")
    continue # Pula o resto do loop
10. Exemplo de como o RAG com Memória melhora a experiência do estudante em um ambiente educacional (em comparação a um RAG sem memória).CenárioRAG sem Memória (Tradicional)RAG com Memória (Melhorado)Estudo de Caso"Quem foi Tiradentes? [Resposta] Depois, o aluno pergunta: 'Ele era de Minas Gerais?' O sistema responde: 'Não sei a quem 'Ele' se refere.'""Quem foi Tiradentes? [Resposta] Depois, o aluno pergunta: 'Ele era de Minas Gerais?' O sistema entende o pronome 18 e responde: 'Sim, Tiradentes era de Minas Gerais.'Melhoria:O sistema não entende pronomes e frases subsequentes19.O sistema reescreve a pergunta (ex: "Ele era de Minas Gerais?" vira "Tiradentes era de Minas Gerais?") 20e permite um diálogo fluido e natural21.